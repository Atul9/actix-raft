syntax = "proto2";
package raft;

// An RPC invoked by the leader to replicate log entries (§5.3); also used as heartbeat (§5.2).
//
// Receiver implementation:
//
// 1. Reply `false` if `term` is less than node's current `term` (§5.1).
// 2. Reply `false` if log doesn’t contain an entry at `prev_log_index` whose term
//    matches `prev_log_term` (§5.3).
// 3. If an existing entry conflicts with a new one (same index but different terms), delete the
//    existing entry and all thatfollow it (§5.3).
// 4. Append any new entries not already in the log.
// 5. If `leader_commit` is greater than node's commit index, set nodes commit index to
//    `min(leader_commit, index of last new entry)`.
message AppendEntriesRequest {
  // The leader's current term.
  required uint64 term = 1;
  // The leader's ID. Useful in redirecting clients.
  required uint64 leader_id = 2;
  // The index of the log entry immediately preceding the new entries.
  required uint64 prev_log_index = 3;
  // The term of the `prev_log_index` entry.
  required uint64 prev_log_term = 4;
  // The new log entries to store.
  //
  // This may be empty when the leader is sending heartbeats. Entries
  // may be batched for efficiency.
  repeated Entry entries = 5;
  // The leader's commit index.
  required uint64 leader_commit = 6;
}

// An RPC response to an `AppendEntriesRequest` message.
message AppendEntriesResponse {
  // The responding node's current term, for leader to update itself.
  required uint64 term = 1;
  // Will be true if follower contained entry matching `prev_log_index` and `prev_log_term`.
  required bool success = 2;
}

// The different types of Raft log entries.
enum EntryType {
  // A normal Raft data entry.
  EntryNormal = 0;
  // An entry which represents a config change.
  EntryConfigChange = 1;
}

// An entry to be committed to the Raft log.
message Entry {
  // This entry's type.
  required EntryType entry_type = 1;
  required uint64 term = 2;
  required uint64 index = 3;
  required bytes data = 4;
}

// An RPC invoked by candidates to gather votes (§5.2).
//
// Receiver implementation:
//
// 1. Reply `false` if `term` is less than receiver's current `term` (§5.1).
// 2. If receiver has not cast a vote for the current `term` or it voted for `candidate_id`, and
//    candidate’s log is atleast as up-to-date as receiver’s log, grant vote (§5.2, §5.4).
message VoteRequest {
  // The candidate's current term.
  required uint64 term = 1;
  // The candidate's ID.
  required uint64 candidate_id = 2;
  // The index of the candidate’s last log entry (§5.4).
  required uint64 last_log_index = 3;
  // The term of the candidate’s last log entry (§5.4).
  required uint64 last_log_term = 4;
}

// An RPC invoked by candidates to gather votes (§5.2).
message VoteResponse {
  // The current term of the responding node, for the candidate to update itself.
  required uint64 term = 1;
  // Will be true if the candidate received a vote from the responder.
  required bool vote_granted = 2;
}
