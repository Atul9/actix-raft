syntax = "proto2";
package raft;

// A Raft request message containing a specific RPC request payload.
message RaftRequest {
  oneof payload {
    AppendEntriesRequest append_entries = 1;
    VoteRequest vote = 2;
    InstallSnapshotRequest install_snapshot = 3;
  }
}

// A Raft response message containing a specific RPC response payload.
message RaftResponse {
  oneof payload {
    AppendEntriesResponse append_entries = 1;
    VoteResponse vote = 2;
    InstallSnapshotResponse install_snapshot = 3;
  }
}

// An RPC invoked by the leader to replicate log entries (§5.3); also used as heartbeat (§5.2).
//
// Receiver implementation:
//
// 1. Reply `false` if `term` is less than node's current `term` (§5.1).
// 2. Reply `false` if log doesn’t contain an entry at `prev_log_index` whose term
//    matches `prev_log_term` (§5.3).
// 3. If an existing entry conflicts with a new one (same index but different terms), delete the
//    existing entry and all thatfollow it (§5.3).
// 4. Append any new entries not already in the log.
// 5. If `leader_commit` is greater than node's commit index, set nodes commit index to
//    `min(leader_commit, index of last new entry)`.
message AppendEntriesRequest {
  // The leader's current term.
  required uint64 term = 1;
  // The leader's ID. Useful in redirecting clients.
  required uint64 leader_id = 2;
  // The index of the log entry immediately preceding the new entries.
  required uint64 prev_log_index = 3;
  // The term of the `prev_log_index` entry.
  required uint64 prev_log_term = 4;
  // The new log entries to store.
  //
  // This may be empty when the leader is sending heartbeats. Entries
  // may be batched for efficiency.
  repeated Entry entries = 5;
  // The leader's commit index.
  required uint64 leader_commit = 6;
}

// An RPC response to an `AppendEntriesRequest` message.
message AppendEntriesResponse {
  // The responding node's current term, for leader to update itself.
  required uint64 term = 1;
  // Will be true if follower contained entry matching `prev_log_index` and `prev_log_term`.
  required bool success = 2;
}

// The different types of Raft log entries.
enum EntryType {
  // A normal Raft data entry.
  EntryNormal = 0;
  // An entry which represents a config change.
  EntryConfigChange = 1;
}

// An entry to be committed to the Raft log.
message Entry {
  // This entry's type.
  required EntryType entry_type = 1;
  required uint64 term = 2;
  required uint64 index = 3;
  required bytes data = 4;
}

// An RPC invoked by candidates to gather votes (§5.2).
//
// Receiver implementation:
//
// 1. Reply `false` if `term` is less than receiver's current `term` (§5.1).
// 2. If receiver has not cast a vote for the current `term` or it voted for `candidate_id`, and
//    candidate’s log is atleast as up-to-date as receiver’s log, grant vote (§5.2, §5.4).
message VoteRequest {
  // The candidate's current term.
  required uint64 term = 1;
  // The candidate's ID.
  required uint64 candidate_id = 2;
  // The index of the candidate’s last log entry (§5.4).
  required uint64 last_log_index = 3;
  // The term of the candidate’s last log entry (§5.4).
  required uint64 last_log_term = 4;
}

// An RPC response to an `VoteResponse` message.
message VoteResponse {
  // The current term of the responding node, for the candidate to update itself.
  required uint64 term = 1;
  // Will be true if the candidate received a vote from the responder.
  required bool vote_granted = 2;
}

// Invoked by leader to send chunks of a snapshot to a follower (§7).
//
// Leaders always send chunks in order.
//
// Receiver implementation:
// 1. Reply immediately if `term` is less than receiver's current `term`.
// 2. Create a new snapshot file if snapshot received is the first chunk
//    of the sanpshot (offset is 0).
// 3. Write data into snapshot file at given offset.
// 4. Reply and wait for more data chunks if `done` is `false`.
// 5. Save snapshot file, discard any existing or partial snapshot with a smaller index.
// 6. If existing log entry has same index and term as snapshot’s last included entry,
//    retain log entries following it and reply.
// 7. Discard the entire log.
// 8. Reset state machine using snapshot contents and load snapshot’s cluster configuration.
message InstallSnapshotRequest {
  // The leader's current term.
  required uint64 term = 1;
  // The leader's ID. Useful in redirecting clients.
  required uint64 leader_id = 2;
  // The snapshot replaces all log entries up through and including this index.
  required uint64 last_included_index = 3;
  // The term of the `last_included_index`.
  required uint64 last_included_term = 4;
  // The byte offset where chunk is positioned in the snapshot file.
  required uint64 offset = 5;
  // The raw bytes of the snapshot chunk, starting at `offset`.
  required bytes data = 6;
  // Will be `true` if this is the last chunk in the snapshot.
  required bool done = 7;
}

// An RPC response to an `InstallSnapshotResponse` message.
message InstallSnapshotResponse {
  // The receiving node's current term, for leader to update itself.
  required uint64 term = 1;
}
