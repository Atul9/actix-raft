syntax = "proto2";
package raft;

// A Raft request message containing a specific RPC request payload.
message RaftRequest {
  oneof payload {
    AppendEntriesRequest append_entries = 1;
    VoteRequest vote = 2;
    InstallSnapshotRequest install_snapshot = 3;
  }
}

// A Raft response message containing a specific RPC response payload.
message RaftResponse {
  oneof payload {
    AppendEntriesResponse append_entries = 1;
    VoteResponse vote = 2;
    InstallSnapshotResponse install_snapshot = 3;
  }
}

// An RPC invoked by the leader to replicate log entries (§5.3); also used as heartbeat (§5.2).
//
// Receiver implementation:
//
// 1. Reply `false` if `term` is less than node's current `term` (§5.1).
// 2. Reply `false` if log doesn’t contain an entry at `prev_log_index` whose term
//    matches `prev_log_term` (§5.3).
// 3. If an existing entry conflicts with a new one (same index but different terms), delete the
//    existing entry and all thatfollow it (§5.3).
// 4. Append any new entries not already in the log.
// 5. If `leader_commit` is greater than node's commit index, set nodes commit index to
//    `min(leader_commit, index of last new entry)`.
message AppendEntriesRequest {
  // The leader's current term.
  required uint64 term = 1;
  // The leader's ID. Useful in redirecting clients.
  required uint64 leader_id = 2;
  // The index of the log entry immediately preceding the new entries.
  required uint64 prev_log_index = 3;
  // The term of the `prev_log_index` entry.
  required uint64 prev_log_term = 4;
  // The new log entries to store.
  //
  // This may be empty when the leader is sending heartbeats. Entries
  // may be batched for efficiency.
  repeated Entry entries = 5;
  // The leader's commit index.
  required uint64 leader_commit = 6;
}

// An RPC response to an `AppendEntriesRequest` message.
message AppendEntriesResponse {
  // The responding node's current term, for leader to update itself.
  required uint64 term = 1;
  // Will be true if follower contained entry matching `prev_log_index` and `prev_log_term`.
  required bool success = 2;
  // A value used to implement the _conflicting term_ optimization outlined in §5.3.
  //
  // This value will only be present, and should only be considered, when `success` is `false`.
  optional ConflictOpt conflict_opt = 3;
}

// A struct used to implement the _conflicting term_ optimization outlined in §5.3 for log replication.
//
// This value will only be present, and should only be considered, when an `AppendEntriesResponse`
// object has a `success` value of `false`.
//
// This implementation of Raft uses this value to more quickly synchronize a leader with its
// followers which may be some distance behind in replication, may have conflicting entries, or
// which may be new to the cluster.
message ConflictOpt {
  // The term of the most recent entry which does not conflict with the received request.
  required uint64 term = 1;
  // The index of the most recent entry which does not conflict with the received request.
  required uint64 index = 2;
}

message Entry {
  required uint64 term = 1;
  required uint64 index = 2;
  // This entry's type.
  oneof entry_type {
    // A normal log entry.
    EntryNormal normal = 3;
    // A config change log entry.
    EntryConfigChange config_change = 4;
    // An entry which points to a snapshot.
    EntrySnapshotPointer snapshot_pointer = 5;
  }
}

// A normal log entry.
message EntryNormal {
  // The contents of this entry.
  required bytes data = 1;
}

// A config change log entry.
message EntryConfigChange {
  // The full list of node IDs to be considered cluster members as part of this config change.
  repeated uint64 members = 1;
  // Any application specific supplemental data asscoiated with this config change.
  optional bytes supplemental = 2;
}

// An entry which points to a snapshot.
//
// This will only be present when read from storage. An entry of this type will never be
// transmitted from a leader, an `InstallSnapshotRequest` will be sent instead.
message EntrySnapshotPointer {
  // The location of the snapshot file on disk.
  required string path = 1;
}

// An RPC invoked by candidates to gather votes (§5.2).
//
// Receiver implementation:
//
// 1. Reply `false` if `term` is less than receiver's current `term` (§5.1).
// 2. If receiver has not cast a vote for the current `term` or it voted for `candidate_id`, and
//    candidate’s log is atleast as up-to-date as receiver’s log, grant vote (§5.2, §5.4).
message VoteRequest {
  // The candidate's current term.
  required uint64 term = 1;
  // The candidate's ID.
  required uint64 candidate_id = 2;
  // The index of the candidate’s last log entry (§5.4).
  required uint64 last_log_index = 3;
  // The term of the candidate’s last log entry (§5.4).
  required uint64 last_log_term = 4;
}

// An RPC response to an `VoteResponse` message.
message VoteResponse {
  // The current term of the responding node, for the candidate to update itself.
  required uint64 term = 1;
  // Will be true if the candidate received a vote from the responder.
  required bool vote_granted = 2;
}

// Invoked by leader to send chunks of a snapshot to a follower (§7).
//
// Leaders always send chunks in order. It is important to note that, according to the Raft spec,
// a log may only have one snapshot at any time. As snapshot contents are application specific,
// the Raft log will only store a pointer to the snapshot file along with the index & term.
//
// Receiver implementation:
// 1. Reply immediately if `term` is less than receiver's current `term`.
// 2. Create a new snapshot file if snapshot received is the first chunk
//    of the sanpshot (offset is 0).
// 3. Write data into snapshot file at given offset.
// 4. Reply and wait for more data chunks if `done` is `false`.
// 5. Save snapshot file, discard any existing or partial snapshot with a smaller index.
// 6. If existing log entry has same index and term as snapshot’s last included entry,
//    retain log entries following it and reply.
// 7. Discard the entire log.
// 8. Reset state machine using snapshot contents and load snapshot’s cluster configuration.
message InstallSnapshotRequest {
  // The leader's current term.
  required uint64 term = 1;
  // The leader's ID. Useful in redirecting clients.
  required uint64 leader_id = 2;
  // The snapshot replaces all log entries up through and including this index.
  required uint64 last_included_index = 3;
  // The term of the `last_included_index`.
  required uint64 last_included_term = 4;
  // The byte offset where chunk is positioned in the snapshot file.
  required uint64 offset = 5;
  // The raw bytes of the snapshot chunk, starting at `offset`.
  required bytes data = 6;
  // Will be `true` if this is the last chunk in the snapshot.
  required bool done = 7;
}

// An RPC response to an `InstallSnapshotResponse` message.
message InstallSnapshotResponse {
  // The receiving node's current term, for leader to update itself.
  required uint64 term = 1;
}
